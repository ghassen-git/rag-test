# Real-Time Agentic RAG System - Cursor Rules

## Project Overview
This is a production-ready Real-Time Retrieval-Augmented Generation (RAG) system with:
- CDC pipeline (Debezium + Kafka)
- Multi-agent architecture (LangGraph)
- Vector database (Milvus)
- OCR processing (Mathpix)
- MCP (Model Context Protocol) integration
- FastAPI REST API

## Technology Stack
- **Language**: Python 3.11+
- **Framework**: FastAPI
- **Agent Framework**: LangGraph
- **Vector DB**: Milvus
- **Databases**: PostgreSQL, MongoDB, Redis
- **Streaming**: Kafka + Debezium
- **Embeddings**: OpenAI text-embedding-3-small
- **LLM**: OpenAI GPT-4
- **OCR**: Mathpix API
- **Containerization**: Docker + Docker Compose

## Code Style & Standards

### Python Style
- Follow PEP 8 style guide
- Use type hints for all function parameters and return values
- Maximum line length: 100 characters
- Use docstrings (Google style) for all classes and functions
- Prefer async/await for I/O operations
- Use f-strings for string formatting

### Example Function Format
```python
async def process_document(
    document_id: str,
    content: str,
    metadata: Dict[str, Any]
) -> Dict[str, Any]:
    """Process a document and generate embeddings.
    
    Args:
        document_id: Unique identifier for the document
        content: Text content to process
        metadata: Additional metadata for the document
        
    Returns:
        Dictionary containing processing results and embedding IDs
        
    Raises:
        ValueError: If content is empty
        ProcessingError: If embedding generation fails
    """
    # Implementation
```

### Imports Organization
```python
# Standard library imports
import logging
from typing import Dict, Any, List, Optional

# Third-party imports
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

# Local imports
from src.config import settings
from src.agents.orchestrator import orchestrator
```

## Project Structure

### Core Directories
- `src/agents/` - Multi-agent system (orchestrator, search, analyst)
- `src/api/` - FastAPI application and endpoints
- `src/cdc/` - CDC pipeline (Debezium, Kafka consumer)
- `src/embedding/` - Chunking and embedding generation
- `src/mcp/` - Model Context Protocol server
- `src/ocr/` - OCR pipeline (Mathpix, PDF processing)
- `src/vector_db/` - Milvus client and schema
- `data/` - Sample data and initialization scripts
- `tests/` - Test files

### Key Files
- `src/config.py` - Configuration management
- `docker-compose.yml` - Infrastructure definition
- `.env` - Environment variables (never commit)
- `requirements.txt` - Python dependencies

## Development Guidelines

### 1. Agent Development
When working with agents:
- Use LangGraph for state management
- Define clear state types with TypedDict
- Implement proper error handling in each node
- Log agent decisions and state transitions
- Use async functions for all agent operations

Example:
```python
class AgentState(TypedDict):
    query: str
    intent: str
    results: List[Dict[str, Any]]
    messages: Annotated[list, operator.add]

async def analyze_intent(state: AgentState) -> AgentState:
    """Analyze user query intent."""
    # Implementation
    return state
```

### 2. API Endpoints
When adding new endpoints:
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Add tags for Swagger organization
- Include comprehensive docstrings
- Define Pydantic models for request/response
- Implement proper error handling
- Add logging for debugging

Example:
```python
@app.post("/endpoint", tags=["Category"])
async def endpoint_name(request: RequestModel):
    """Endpoint description.
    
    Detailed explanation of what this endpoint does.
    """
    try:
        # Implementation
        return {"success": True, "data": result}
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

### 3. Database Operations
- Always use connection pooling
- Implement proper error handling and retries
- Use transactions for multi-step operations
- Close connections properly
- Log all database operations

### 4. Vector Database (Milvus)
- Use upsert for idempotent operations
- Implement proper indexing (HNSW)
- Handle connection failures gracefully
- Batch operations when possible
- Monitor collection statistics

### 5. CDC Pipeline
- Ensure idempotent event processing
- Handle duplicate events
- Log all CDC events
- Implement proper error recovery
- Monitor Kafka lag

### 6. MCP Integration
- Define clear tool schemas
- Implement async handlers
- Validate parameters
- Return structured responses
- Document all tools and resources

## Error Handling

### Standard Pattern
```python
try:
    result = await operation()
    logger.info(f"Operation successful: {result}")
    return result
except SpecificError as e:
    logger.error(f"Specific error: {e}")
    raise HTTPException(status_code=400, detail=str(e))
except Exception as e:
    logger.error(f"Unexpected error: {e}", exc_info=True)
    raise HTTPException(status_code=500, detail="Internal server error")
```

### Logging Levels
- `DEBUG`: Detailed information for debugging
- `INFO`: General information about system operation
- `WARNING`: Warning messages for potential issues
- `ERROR`: Error messages for failures
- `CRITICAL`: Critical issues requiring immediate attention

## Testing

### Test Structure
```python
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_endpoint():
    """Test endpoint functionality."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/endpoint", json={"key": "value"})
        assert response.status_code == 200
        assert response.json()["success"] is True
```

### Test Coverage
- Unit tests for individual functions
- Integration tests for API endpoints
- End-to-end tests for complete workflows
- Mock external services (OpenAI, Mathpix)

## Configuration

### Environment Variables
Always use environment variables for:
- API keys (OpenAI, Mathpix)
- Database credentials
- Service URLs
- Feature flags

Access via `src/config.py`:
```python
from src.config import settings

api_key = settings.openai_api_key
```

### Never Commit
- `.env` file
- API keys
- Credentials
- Personal data
- Large binary files

## Docker & Deployment

### Docker Compose
- Use named volumes for persistence
- Define health checks for all services
- Set resource limits
- Use networks for service isolation
- Document all environment variables

### Service Dependencies
```yaml
depends_on:
  postgres:
    condition: service_healthy
  kafka:
    condition: service_started
```

## Performance Optimization

### Best Practices
- Use async/await for I/O operations
- Implement caching (Redis) for frequent queries
- Batch database operations
- Use connection pooling
- Monitor and optimize slow queries
- Implement rate limiting

### Caching Strategy
```python
@cache(ttl=300)  # 5 minutes
async def get_book_metadata(book_id: str):
    """Get book metadata with caching."""
    return await db.query(book_id)
```

## Security

### API Security
- Validate all input data
- Sanitize user inputs
- Use HTTPS in production
- Implement rate limiting
- Add authentication/authorization
- Never expose internal errors to users

### Data Security
- Encrypt sensitive data at rest
- Use secure connections (SSL/TLS)
- Implement proper access controls
- Audit all data access
- Follow GDPR/privacy regulations

## Documentation

### Code Documentation
- Docstrings for all public functions/classes
- Inline comments for complex logic
- Type hints for all parameters
- Examples in docstrings when helpful

### API Documentation
- Use FastAPI's automatic OpenAPI generation
- Add detailed descriptions to endpoints
- Provide request/response examples
- Document error codes and messages

### Project Documentation
- Keep README.md up to date
- Document architecture decisions
- Maintain changelog
- Provide setup instructions
- Include troubleshooting guide

## Git Workflow

### Commit Messages
Format: `<type>(<scope>): <subject>`

Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes
- `refactor`: Code refactoring
- `test`: Test additions/changes
- `chore`: Maintenance tasks

Example:
```
feat(api): add MCP endpoints for tool calling
fix(cdc): handle duplicate Kafka events
docs(readme): update setup instructions
```

### Branch Naming
- `feature/description` - New features
- `fix/description` - Bug fixes
- `refactor/description` - Code refactoring
- `docs/description` - Documentation updates

## Common Patterns

### Async Context Manager
```python
async with AsyncClient() as client:
    response = await client.get(url)
```

### Dependency Injection (FastAPI)
```python
async def get_db():
    db = Database()
    try:
        yield db
    finally:
        await db.close()

@app.get("/endpoint")
async def endpoint(db: Database = Depends(get_db)):
    return await db.query()
```

### Background Tasks
```python
from fastapi import BackgroundTasks

@app.post("/process")
async def process(background_tasks: BackgroundTasks):
    background_tasks.add_task(long_running_task)
    return {"status": "processing"}
```

## Monitoring & Observability

### Logging
```python
import logging

logger = logging.getLogger(__name__)

logger.info("Operation started")
logger.error("Operation failed", exc_info=True)
```

### Metrics
- Track API response times
- Monitor database query performance
- Track CDC event processing lag
- Monitor vector database operations
- Alert on error rates

### Health Checks
Implement comprehensive health checks:
```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "components": {
            "milvus": check_milvus(),
            "postgres": check_postgres(),
            "mongodb": check_mongodb()
        }
    }
```

## Troubleshooting

### Common Issues
1. **Milvus connection fails**: Check if service is running, verify credentials
2. **Kafka lag**: Increase consumer threads, optimize processing
3. **Slow queries**: Add indexes, optimize query patterns
4. **Memory issues**: Implement batching, reduce batch sizes
5. **OCR failures**: Check Mathpix API limits, use fallback (PyPDF2)

### Debug Mode
Enable debug logging:
```python
logging.basicConfig(level=logging.DEBUG)
```

## AI Assistant Guidelines

When helping with this project:
1. Follow the established patterns and conventions
2. Maintain consistency with existing code style
3. Add proper error handling and logging
4. Include type hints and docstrings
5. Consider performance implications
6. Ensure backward compatibility
7. Update documentation when needed
8. Write tests for new functionality
9. Follow security best practices
10. Keep dependencies up to date

## Quick Reference

### Start Development
```bash
docker-compose up -d
python -m uvicorn src.api.main:app --reload
```

### Run Tests
```bash
pytest tests/ -v
```

### Check Code Style
```bash
black src/
flake8 src/
mypy src/
```

### View Logs
```bash
docker-compose logs -f rag-app
```

### Access Services
- API: http://localhost:8000
- Swagger: http://localhost:8000/docs
- Milvus: localhost:19530
- PostgreSQL: localhost:5432
- MongoDB: localhost:27017
- Kafka: localhost:9092

## Resources

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/)
- [Milvus Documentation](https://milvus.io/docs)
- [Debezium Documentation](https://debezium.io/documentation/)
- [OpenAI API Reference](https://platform.openai.com/docs/api-reference)

---

**Remember**: Write clean, maintainable, well-documented code. When in doubt, follow existing patterns in the codebase.
